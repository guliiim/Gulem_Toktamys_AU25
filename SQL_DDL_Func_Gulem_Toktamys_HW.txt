Task 6. Analyze the existing functions in the dvd_rental database and prepare answers to the following questions


1.What operations do the following functions perform: film_in_stock, film_not_in_stock, inventory_in_stock, get_customer_balance, inventory_held_by_customer, rewards_report, last_day? You can find these functions in dvd_rental database.
film_in_stock: It returns a list of inventory_id values ​​for movie copies currently available for sale in the specified store. 
film_not_in_stock: It returns a list of inventory_id values ​​for currently rented movie copies.
inventory_in_stock: It checks if a specific movie copy is in stock.
get_customer_balance: It calculates the amount a customer owes on a specific date.
inventory_held_by_customer: It returns the customer_id of the currently rented movie, if it has not already been returned.
rewards_report: Based on the previous month's payment history, returning customers who meet the rewards program criteria will receive a reward.
last_day: It returns the last day of the month corresponding to the given timestamp.




2.Why does ‘rewards_report’ function return 0 rows? Correct and recreate the function, so that it's able to return rows properly.
The rewards_report function returns 0 rows because it calculates the “last month” using:
last_month_start := CURRENT_DATE - INTERVAL '3 month';
last_month_start := to_date(... '-01', 'YYYY-MM-DD');
last_month_end := last_day(last_month_start);
This means the function always looks at payments within the last 2–3 months from today.
The function uses CURRENT_DATE, which does not match the period of the historical sample data.


after change:
CREATE OR REPLACE FUNCTION public.rewards_report(
    min_monthly_purchases integer,
    min_dollar_amount_purchased numeric
)
RETURNS SETOF customer
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    last_month_start DATE;
    last_month_end   DATE;
    rr               RECORD;
    tmpSQL           TEXT;
BEGIN
    IF min_monthly_purchases <= 0 THEN
        RAISE EXCEPTION 'Minimum monthly purchases must be > 0';
    END IF;


    IF min_dollar_amount_purchased <= 0 THEN
        RAISE EXCEPTION 'Minimum monthly amount must be > 0';
    END IF;


    -- FIX: Use the latest month from existing payment data
    SELECT DATE_TRUNC('month', MAX(payment_date))::date
    INTO last_month_start
    FROM payment;


    last_month_end := last_day(last_month_start);


    CREATE TEMPORARY TABLE tmpCustomer (
        customer_id INTEGER PRIMARY KEY
    ) ON COMMIT DROP;


    tmpSQL := '
        INSERT INTO tmpCustomer (customer_id)
        SELECT p.customer_id
        FROM payment p
        WHERE DATE(p.payment_date)
              BETWEEN ' || quote_literal(last_month_start) || ' AND ' ||
                           quote_literal(last_month_end) || '
        GROUP BY p.customer_id
        HAVING SUM(p.amount) > ' || min_dollar_amount_purchased || '
           AND COUNT(*) > '     || min_monthly_purchases;


    EXECUTE tmpSQL;


    RETURN QUERY
    SELECT c.*
    FROM tmpCustomer t
    JOIN customer c USING (customer_id);
END
$function$;
The corrected solution replaces CURRENT_DATE with the last existing payment month, using MAX(payment_date), ensuring that the function works with the real data in the database.




3.Is there any function that can potentially be removed from the dvd_rental codebase? If so, which one and why?
Yes. The group_concat and _group_concat functions can be removed.
Because PostgreSQL provides string_agg(), which performs the same task more efficiently.




4.* The ‘get_customer_balance’ function describes the business requirements for calculating the client balance. Unfortunately, not all of them are implemented in this function. Try to change function using the requirements from the comments.
Solution:
CREATE OR REPLACE FUNCTION public.get_customer_balance(
    p_customer_id INTEGER,
    p_effective_date TIMESTAMPTZ
)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $function$
--#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
--#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
--#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
--#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
--#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
--#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
DECLARE
    v_rent_fees NUMERIC(8,2) := 0;
    v_late_fees NUMERIC(8,2) := 0;
    v_payments  NUMERIC(8,2) := 0;
    r RECORD;
    v_due_date TIMESTAMPTZ;
    v_days_overdue INTEGER;
BEGIN
    --1. Rental fees
    SELECT COALESCE(SUM(f.rental_rate), 0)
    INTO v_rent_fees
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film f ON i.film_id = f.film_id
    WHERE r.customer_id = p_customer_id
      AND r.rental_date <= p_effective_date;


    -- 2，3. Late fees and replacement cost
    FOR r IN
        SELECT r.rental_id,
               r.rental_date,
               r.return_date,
               f.rental_duration,
               f.replacement_cost
        FROM rental r
        JOIN inventory i ON r.inventory_id = i.inventory_id
        JOIN film f ON i.film_id = f.film_id
        WHERE r.customer_id = p_customer_id
          AND r.rental_date <= p_effective_date
    LOOP
        v_due_date := r.rental_date + (r.rental_duration || ' days')::interval;


        IF r.return_date IS NOT NULL THEN
            v_days_overdue := GREATEST(0, (r.return_date - v_due_date)) / INTERVAL '1 day';
        ELSE
            v_days_overdue := GREATEST(0, (p_effective_date - v_due_date)) / INTERVAL '1 day';
        END IF;


        v_late_fees := v_late_fees + v_days_overdue;


        IF v_days_overdue > r.rental_duration * 2 THEN
            v_late_fees := v_late_fees + r.replacement_cost;
        END IF;
    END LOOP;


    --4. Payments
    SELECT COALESCE(SUM(amount), 0)
    INTO v_payments
    FROM payment
    WHERE customer_id = p_customer_id
      AND payment_date <= p_effective_date;


    RETURN v_rent_fees + v_late_fees - v_payments;
END;
$function$;




5.* How do ‘group_concat’ and ‘_group_concat’ functions work? (database creation script might help) Where are they used?
It contains the functions ‘_group_concat’ and ‘group_concat’, which together implement a custom text aggregation mechanism.
‘_group_concat’ is a state transition function. It takes the current aggregated text and the next value, and concatenates them using a comma separator. ‘group_concat’ is an aggregation function built upon ‘_group_concat’. It iterates through the rows in the group and returns a comma-separated string containing all the values.
These functions are primarily used in the ‘rewards_report’ function to generate a comma-separated list of movies for a report.




6.* What does ‘last_updated’ function do? Where is it used?
The ‘last_updated’ function is a trigger function that automatically sets the ‘last_update’ column of a row to the current timestamp when a row is updated. Multiple ‘BEFORE UPDATE’ triggers in the DVD rental database use this function, such as triggers in tables like customer, actor, film, address, store, inventory, and others that contain a ‘last_update’ column.


7.* What is tmpSQL variable for in ‘rewards_report’ function? Can this function be recreated without EXECUTE statement and dynamic SQL? Why?
The ‘tmpSQL’ variable in the ‘rewards_report’ table stores a dynamically constructed SQL statement executed using ‘EXECUTE’, which inserts matching customer IDs into a temporary table. Dynamic SQL allows parameters to be concatenated into the query string.


It's not necessary to use ‘EXECUTE’, as this can be achieved using a regular ‘INSERT INTO ... SELECT ... HAVING …’ query that directly references the parameters. Dynamic SQL is not needed here because all table names, column names, and types are known at design time, and PostgreSQL allows parameters in the ‘HAVING’ clause.